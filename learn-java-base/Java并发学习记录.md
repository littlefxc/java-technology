# java 并发学习记录

## 概念介绍

- 临界区  
表示共享数据。可以有多个线程使用它，但同一时间只能被一个线程使用，其它线程只能等待

- 同步/异步  
同步：实时处理。可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息。  
异步：分时处理。执行完函数或方法后，不必阻塞性地等待返回值或消息。

- 并发/并行  
并发：侧重于多个任务交替执行。  
并行：多个任务同时执行。

- 阻塞/非阻塞  
阻塞：同步  
非阻塞：异步

- 死锁/饥饿/活锁
    - 死锁：多个任务执行条件首尾相连。（执行任务A需要先执行任务B，执行任务B需要先执行任务A）。
    - 饥饿：高优先级线程一直抢占资源，导致其它需要这个资源的任务无法执行。
    - 活锁：多个线程不停的释放资源，导致资源在多个线程跳转以致没有一个线程可以拿到资源去执行任务。

- 并发级别  
    - 阻塞
    - 无饥饿
    - 无障碍
    - 无锁
    - 无等待
    
## Java 内存模型（JMM）

JMM 的关键技术点都是围绕着多线程的**原子性**、**可见性**和**有序性**来建立的。

- 原子性：原子性是指一个操作是不可中断的。即使在多个线程一起执行的时候，一个操作一旦开始，就不会被其它线程干扰。

- 可见性：可见性是指当一个线程修改了某个共享变量的值。其它线程是否能够立即知道这个修改。

- 有序性：有序性是指程序在执行时，两条语句可能会发生指令重排。
    - 哪些指令不能重排：
        - [ ] 程序顺序原则：一个线程内保证语义的串行性
        - [ ] volatile规则：volatile变量的写，先发生于读，保证了volatile变量的可见性
        - [ ] 锁规则：解锁(unlock) 必然发生在随后的加锁(lock) 前
        - [ ] 传递性：A 先于 B，B 先于 C，那么 A 必然先于 C
        - [ ] 线程的 start() 方法先于它的每一个动作
        - [ ] 线程的所有操作先于线程的终结 `Thread.join()`
        - [ ] 线程的中断 `interrupt()` 先于被中断线程的代码
        - [ ] 对象的构造函数执行、结束先于 `finalize()` 方法



