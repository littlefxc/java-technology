# java 并发学习记录

## 概念介绍

- 临界区  
表示共享数据。可以有多个线程使用它，但同一时间只能被一个线程使用，其它线程只能等待

- 同步/异步  
同步：实时处理。可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息。  
异步：分时处理。执行完函数或方法后，不必阻塞性地等待返回值或消息。

- 并发/并行  
并发：侧重于多个任务交替执行。  
并行：多个任务同时执行。

- 阻塞/非阻塞  
阻塞：同步  
非阻塞：异步

- 死锁/饥饿/活锁
  - 死锁：多个任务执行条件首尾相连。（执行任务A需要先执行任务B，执行任务B需要先执行任务A）。
  - 饥饿：高优先级线程一直抢占资源，导致其它需要这个资源的任务无法执行。
  - 活锁：多个线程不停的释放资源，导致资源在多个线程跳转以致没有一个线程可以拿到资源去执行任务。

- 并发级别  
  - 阻塞
  - 无饥饿
  - 无障碍
  - 无锁
  - 无等待

## Java 内存模型（JMM）

JMM 的关键技术点都是围绕着多线程的**原子性**、**可见性**和**有序性**来建立的。

- 原子性：原子性是指一个操作是不可中断的。即使在多个线程一起执行的时候，一个操作一旦开始，就不会被其它线程干扰。

- 可见性：可见性是指当一个线程修改了某个共享变量的值。其它线程是否能够立即知道这个修改。

- 有序性：有序性是指程序在执行时，两条语句可能会发生指令重排。
  - 哪些指令不能重排：
    - 程序顺序原则：一个线程内保证语义的串行性
    - volatile规则：volatile变量的写，先发生于读，保证了volatile变量的可见性
    - 锁规则：解锁(unlock) 必然发生在随后的加锁(lock) 前
    - 传递性：A 先于 B，B 先于 C，那么 A 必然先于 C
    - 线程的 start() 方法先于它的每一个动作
    - 线程的所有操作先于线程的终结 `Thread.join()`
    - 线程的中断 `interrupt()` 先于被中断线程的代码
    - 对象的构造函数执行、结束先于 `finalize()` 方法

## Thread 的常用方法记录

- `currentThead()`  
  返回对当前正在执行的线程对象的引用。

- `getId()`  
  返回此线程的标识符

- `getName()`  
  返回此线程的名称

- `getPriority()`  
  返回此线程的优先级

- `isAlive()` 
  判断这个线程是否还处于活动状态。
  活动状态就是线程已经启动且尚未终止。线程处于正在运行或准备运行的状态。

- `sleep(long millis)`  
  使当前正在执行的线程以指定的毫秒数“休眠”（暂时停止执行），具体取决于系统定时器和调度程序的精度和准确性。

- `interrupt()`  
  中断这个线程。

- `interrupted()` 和 `isInterrupted()`
  - `interrupted()`：判断当前线程是否已经是中断状态，执行后具有将状态标志清除为false的功能
  - `isInterrupted()`：判断线程Thread对相关是否已经是中断状态，但不清除状态标志

- `setName(String name)`  
  将此线程的名称更改为等于参数 name 。

- `isDaemon()`
  判断这个线程是否是守护线程。

- `setDaemon(boolean on)`  
  将此线程标记为 daemon 线程或用户线程。

- `join()`  
  在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，
  主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，
  需要用到子线程的处理结果，也就是**主线程需要等待子线程执行完成之后再结束，这个时候就要用到 `join()` 方法了**。

  `join()` 的作用是：“**等待该线程终止**”，这里需要理解的就是该线程是指的主线程等待子线程的终止。
  也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行

- `yield()`  
  yield()方法的作用是放弃当前的CPU资源，将它让给其他的任务去占用CPU时间。注意：放弃的时间不确定，
  可能一会就会重新获得CPU时间片。

- `setPriority(int newPriority)`  
  更改此线程的优先级

## 如何停止线程

stop(),suspend(),resume()（仅用于与suspend()一起使用）这些方法已被弃用。

- [ ] [如何停止线程.md](如何停止线程.md)

## 线程的优先级

每个线程都具有各自的优先级，**线程的优先级可以在程序中表明该线程的重要性，如果有很多线程处于就绪状态，
系统会根据优先级来决定首先使哪个线程进入运行状态**。但这个并不意味着低
优先级的线程得不到运行，而只是它运行的几率比较小，如垃圾回收机制线程的优先级就比较低。所以很多垃圾得不到及时的回收处理。

**线程优先级具有继承特性**比如A线程启动B线程，则B线程的优先级和A是一样的。

**线程优先级具有随机性**也就是说线程优先级高的不一定每一次都先执行完。

Thread类中包含的成员变量代表了线程的某些优先级。如Thread.MIN_PRIORITY（常数1），Thread.NORM_PRIORITY（常数5）,
Thread.MAX_PRIORITY（常数10）。其中每个线程的优先级都在Thread.MIN_PRIORITY（常数1） 到Thread.MAX_PRIORITY（常数10） 之间，
在默认情况下优先级都是Thread.NORM_PRIORITY（常数5）。

## 守护线程

用户线程：运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程

守护线程：运行在后台，为其他前台线程服务.
  - 特点：一旦所有用户线程都结束运行，守护线程会随JVM一起结束工作
  - 应用：数据库连接池中的检测线程，JVM虚拟机启动后的检测线程  
  最常见的守护线程：垃圾回收线程
  
### 如何设置守护线程？

可以通过调用 Thead 类的 `setDaemon(true)` 方法设置当前的线程为守护线程

**tips**:

  1. `setDaemon(true)` 必须在 `start()` 方法前执行，否则会抛出 `IllegalThreadStateException` 异常
  2. 在守护线程中产生的新线程也是守护线程
  3. 不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑等需要大量资源的操作
